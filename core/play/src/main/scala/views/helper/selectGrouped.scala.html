@**
 * Generate an HTML select.
 *
 * Example:
 * {{{
 * @selectGrouped(
 *   field = myForm("mySelect"),
 *   options = Seq(
 *     "" -> Seq(
 *       "opt1" -> "Option without a group",
 *       "opt2" -> "Another option without group"
 *     ),
 *     "Group 1" -> Seq(
 *       "opt3" -> "Option 3",
 *       "opt4" -> "Option 4"
 *     ),
 *     "Group 2" -> Seq(
 *       "opt5" -> "Option 5",
 *       "opt6" -> "Option 6"
 *     )
 *    ),
 *   Symbol("_default") -> "Choose One",
 *   Symbol("_disabled") -> Seq("opt1", "opt3")
 *   Symbol("_disabledGroups") -> Seq("Group 2")
 *   Symbol("cust_att_name") -> "cust_att_value"
 * )
 * }}}
 *
 * @param field The form field.
 * @param options Sequence of options as pairs of value and HTML.
 * @param args Set of extra attributes.
 * @param handler The field constructor.
 *@
@(field: play.api.data.Field, optionGroups: Seq[(String,Seq[(String,String)])], args: (Symbol,Any)*)(implicit handler: FieldConstructor, messages: play.api.i18n.MessagesProvider)
@input(field, args:_*) { (id, name, value, htmlArgs) =>
    @defining( if( htmlArgs.contains(Symbol("multiple")) ) "%s[]".format(name) else name ) { selectName =>
    @defining( field.indexes.nonEmpty && htmlArgs.contains(Symbol("multiple")) match {
            case true => field.indexes.map( i => field("[%s]".format(i)).value ).flatten.toSet
            case _ => field.value.toSet
    }){ selectedValues =>
        <select id="@id" name="@selectName" @toHtmlArgs(htmlArgs)>
            @args.toMap.get(Symbol("_default")).map { defaultValue =>
                <option class="blank" value="">@translate(defaultValue)</option>
            }
            @optionGroups.map { case (group, options) =>
                @if(!group.isEmpty) {
                    @defining( args.toMap.get(Symbol("_disabledGroups")).exists { case s: Seq[_] => s.asInstanceOf[Seq[String]].contains(group)}){ disabledGroup =>
                        <optgroup label="@group"@if(disabledGroup){ disabled}>
                    }
                }
                @options.map { case (k, v) =>
                    @defining( selectedValues.contains(k) ) { selected =>
                    @defining( args.toMap.get(Symbol("_disabled")).exists { case s: Seq[_] => s.asInstanceOf[Seq[String]].contains(k) }){ disabled =>
                    <option value="@k"@if(selected){ selected="selected"}@if(disabled){ disabled}>@v</option>
                }}}
                @if(!group.isEmpty) {
                    </optgroup>
                }
            }
        </select>
    }}
}
